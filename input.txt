Monstera: Company Metric Design

Introduction

Monstera is a project designed to build a robust ecosystem of metrics that explain how entities interact with products and features. These metrics are anchored in the core events that drive engagement on the platform, allowing for a granular view of the company’s operations. The metric structure follows an event tree hierarchy, enabling teams across product, operations, and engineering to zoom in and out—whether they need to observe overarching trends or focus on specific entity actions over varying timeframes.

The framework promotes a structured, disciplined approach to understanding business performance. By standardizing key events, every team is encouraged to think of their role in the company as a lever that influences the flow of entities and their actions through various aspects of the organization. Engineering teams are responsible for implementing specific entity events and ensuring the accuracy of the data sent to the pipeline. The data team ensures all data is properly gathered and adheres to set standards. Meanwhile, product and operations teams are tasked with maintaining the business logic, ensuring that the data reflects accurate and actionable insights for decision-making. Leadership will continuously track these metrics against company goals and objectives, providing a clear view of how different functions contribute to overall success.

Moreover, this structured approach extends beyond just metrics—it is reflected in the design of the dashboards used by the teams. The dashboards follow a similar tree structure, allowing users to start at high-level company metrics and drill down to more granular, event-level data. This seamless movement between layers ensures that teams can quickly identify trends and diagnose issues. All dashboards will be certified by the data team, ensuring accuracy and consistency across the organization.

To guarantee reliability, all events will adhere to a transactional structure. These events will capture relevant information about the entity, the type of entity, the action taken, and the location where the event occurred. This core object model standardizes data collection, ensuring that all critical attributes are captured consistently, which not only aids in analysis but also ensures that decisions are based on comprehensive and reliable data.

This opinionated approach to metric design avoids the pitfalls of disjointed metrics developed independently by different teams, which can fragment focus and dilute the company’s resources. Historically, businesses that have failed to maintain a unified metric strategy have suffered from slow growth and missed opportunities to truly understand their operational dynamics. By focusing on a structured metric and dashboard design, Monstera ensures that the company maintains its focus, fostering both scalability and deep insights into the way the business operates.

Metrics as the Cornerstone of Decision-Making

Metrics are the foundation upon which informed decision-making is built. For metrics to be a reliable asset in any organization, they must be developed in a stable and trustworthy manner. Inconsistent or loosely defined metrics can undermine confidence at every level—from senior leadership down to the individuals responsible for creating events and maintaining business logic. A lack of standardized and robust metrics not only leads to unreliable forecasting but also hinders the ability to set and achieve meaningful monthly or quarterly goals.

One of the key challenges that organizations face when developing metrics is “metric drift”—the slow evolution of metric definitions as different teams interpret business logic in various ways. Without centralized definitions, teams may inadvertently deviate from the original intent of a metric, resulting in inconsistent data that lacks clarity and alignment. This fragmentation makes it difficult to identify the “golden data”—the most valuable, standardized data that drives key decisions around adoption, retention, and performance improvement. Establishing and maintaining a rigorous, standardized approach to metric development is essential for avoiding this drift.

Once metrics are standardized, they enhance the company's ability to perform ad hoc analysis with greater efficiency and accuracy. Clean, well-defined data allows for the identification of patterns and trends, enabling stakeholders across the company to make faster, more informed decisions. Self-service analytics becomes significantly easier as the data takes on a consistent shape, with clear definitions, lineage, and documentation that reduce the barriers to independent exploration. Teams can dive into the data without the need for constant guidance from the data team, fostering a more data-driven culture across the organization.

In addition to easing ad hoc analysis, standardized metrics are critical in enabling reliable alerting systems. When rules behind alerts are well-documented and consistently applied, stakeholders are better equipped to understand and react to anomalies in the data. If an alert fires, everyone understands the logic behind it, making it easier to diagnose issues and determine whether the anomaly is due to external factors or internal system changes. This responsiveness to anomalies helps in maintaining operational integrity and avoiding missed opportunities or unchecked risks.

Moreover, standardized metrics and clean data significantly streamline more advanced analytical processes. Operations such as descriptive statistics, hypothesis testing, correlation analysis, and time series analysis all depend on the quality and consistency of the underlying data. Without trustworthy metrics, these operations become less reliable, as the noise from inconsistent or poorly defined data obscures meaningful insights. A disciplined approach to metric design ensures that these statistical and analytical methods can be applied with confidence, yielding actionable insights that drive business growth and operational efficiency.

By developing metrics that are reliable, well-documented, and consistent across the company, Monstera creates a robust foundation for both everyday decision-making and long-term strategic planning. These metrics provide the clarity needed to understand performance, identify opportunities, and react effectively to challenges, ensuring that the entire organization is aligned and moving in the right direction.

Implementation: Turning Philosophy into Action

1. Surveying the Data Landscape
Before any code is written or data is moved, it is crucial to first conduct a comprehensive survey of the data landscape. This involves mapping out how entities (such as users, accounts, videos, or projects) interact with products and features, and understanding the relationships between these interactions. For instance, consider the workflow where a user signs up for an account, creates a video project, adds comments to different parts of the video, and publishes it. Each of these actions follows a specific order, and mapping this sequence helps define how the metrics will be structured.

Key points in this phase include:

Identify unique vs. repeatable events: Some events, like account creation, happen once, while others, like adding videos or comments, may occur multiple times. Recognizing this distinction ensures that the metrics capture the correct frequency of actions, and helps with setting up alerts to track the different types of events.
Map event dependencies: Understanding the flow of actions (e.g., publishing a video can only happen after it has been created and edited) ensures that workflows are correctly mapped. This hierarchical view will become the foundation of the event tree used in metrics.
Explore workflow boundaries: Not all interactions need to be mapped at once, but key workflows should be defined early to ensure that critical actions are captured. As new workflows emerge, they should be carefully integrated to allow for controlled experiments like A/B testing or other ad hoc analysis.
By fully understanding the flow of interactions, we can begin to frame the data model that will be used to generate reliable and accurate metrics.

2. Designing Event Trees and Metrics
Once the data landscape is well understood, the next step is to design the event trees that will feed into the metrics. Event trees represent how various entity interactions can be grouped into meaningful sequences, forming the backbone of the metric system.

Create a hierarchy of events: Start by defining the top-level events that represent major user actions (e.g., signing up, uploading a video, publishing content). Beneath each top-level event, smaller sub-events may occur (e.g., within the process of uploading a video, there could be stages like adding a title, uploading the file, and saving the draft).
Define standard metrics for each workflow: With the event trees in place, metrics can be created to measure the performance of each key event. These metrics could include user engagement rates (e.g., how many users progress through all steps of video creation), retention rates, and frequency of specific actions.
Iterative approach to metric creation: While the entire company doesn’t need to be mapped out initially, complete workflows for critical processes must be defined to avoid gaps in data. As new workflows or product features are introduced, the event trees can be expanded or refined accordingly.
3. Building Standardized Data Models
With the event trees and entity workflows established, the next step is to develop standardized data models that centralize and organize data in a way that enables clean, consistent metric calculations. These models serve as the foundation for how data is stored, accessed, and transformed into actionable insights.

Create action-focused tables: Centralize all actions or activities that entities perform into "action tables." These tables should consolidate data from various sources but maintain a focus on the specific activities taken by entities within defined families. For example, all actions taken in the video creation and update workflow should be grouped together. User signup and member invitations should be in a separate flow.

Entity vs. activity tables: To maintain clarity and separation of concerns, create two types of tables:

Activity/action tables: Capture all interactions and activities performed by entities, such as logging in, uploading videos, or posting comments. These tables organize actions in a structured and chronological manner. Transactional data preferred.
Entity tables: Store the descriptive data related to entities themselves (e.g., user profiles, account details, video metadata). These tables reflect the latest state of each entity, allowing for easy enrichment of the action tables when performing analysis. CDC or similar tables structure preferred.
4. Building Metrics Values
Once the data models are in place, the final step is to calculate the metrics themselves. The calculation of metrics can vary based on the company’s data infrastructure, and there are multiple approaches to choose from, depending on the level of complexity and the desired responsiveness of the system.

Enriching action data with entity data: At this stage, it is crucial to join the action tables back with the entity tables. This step allows for segmenting the overall metrics into more granular metrics based on key attributes of the entities. For example, instead of just tracking general activity metrics (like login frequency or video uploads), we can create more specific metrics by segmenting the data. Some examples include:

Frequency by country: Using the entity data (e.g., user profiles or account information), actions can be segmented by location to analyze regional performance trends.
Metrics by account age: Segmenting metrics based on how long a user has had an account (e.g., new users versus long-time users) can offer insights into engagement or retention.
Other demographic or entity-based segments: Depending on the available attributes in the entity tables, further segmentation can be applied (e.g., industry, role, account type, or other key identifiers).
By enriching the action data with relevant entity information, the company can create tailored views of performance for different segments, making it easier to understand how certain entity characteristics affect the metrics.

Cube-based approach: One method for calculating metrics is to structure the data into a multi-dimensional cube, allowing for dynamic calculations at query time. This approach offers flexibility and allows users to quickly slice and dice data based on different entity segments (e.g., country, age group, etc.). However, dynamic calculations may require significant computational resources and may affect query performance as the volume of data grows.

Pre-computed metrics: In cases where performance is a concern, metrics can be pre-aggregated and stored in summary tables. This method allows for faster queries since metrics are calculated ahead of time, but the trade-off is that the data may not reflect the most recent activities. Even in a pre-computed approach, it’s important to ensure that action data is correctly enriched with entity data to enable segmented views of the metrics.

Hybrid approaches: Depending on the specific needs and technical infrastructure, a combination of cube-based and pre-computed metrics can be used. For example, high-frequency metrics like daily login counts can be calculated dynamically, while more stable metrics like monthly active users or long-term retention rates can be pre-computed and segmented by various entity attributes.

By joining action and entity tables, metrics become far more versatile and informative. Segmenting metrics based on entity characteristics allows for deeper insights, which is essential for understanding different user behaviors, trends, and key performance drivers across various segments of the business. This step is a critical part of transforming raw data into actionable insights that drive more granular and targeted decision-making.

Dashboard Design: Structuring Metrics for Actionable Insights

A well-designed dashboard is essential for conveying metrics in a clear and actionable way. The goal of the Monstera dashboard design is to provide a structured, intuitive view of the company’s key metrics while maintaining consistency and clarity across all dashboards. To achieve this, dashboards will follow a tree structure, with three types of dashboards—Overall View, Segment View, and Activity View—each rolling up into the next. This approach ensures users can easily navigate from detailed activity metrics all the way up to high-level company performance, without losing context.

1. Dashboard Types and Tree Structure The three dashboard types follow a hierarchical structure, allowing users to zoom in and out based on their level of analysis.

Overall View Dashboards:
These are the top-level dashboards that provide a holistic view of the company’s most important metrics. Designed for leadership and strategic decision-making, these dashboards include big number tiles to highlight the current state of key metrics such as total active users, revenue, or retention rates. Additionally, line or bar chart can be found here, but they will only include the last 90-days of data. Users will also be able to drill down from the Overall View into Segment or Activity View dashboards for a more detailed analysis.

Example: The overall dashboard might include metrics like “Monthly Active Users” or “Total Revenue,” each represented with big number tiles alongside line and bar charts that show trends over time.

Segment View Dashboards:
The Segment View dashboards focus on breaking down the overall metrics by key entity segments, such as geography, account type, or product usage. These dashboards allow users to understand how different segments contribute to the overall performance and identify trends or anomalies in specific groups. Line and bar charts will include up to 18-months of data.

Example: A Segment View dashboard might include a chart for “Monthly Active Users by Country” or “Revenue by Account Age,” allowing teams to explore how different segments of the user base behave.

Activity View Dashboards:
The Activity View dashboards are the most granular level, focusing on specific actions or workflows taken by entities. These dashboards show how users interact with the platform in detail, such as the number of videos uploaded, the average time spent on specific features, or the frequency of comments on videos. Activity metrics roll up into Segment Views, providing insights into how actions differ across various segments. Line and bar charts will include up to 18-months of data.

Example: An Activity View dashboard might track “Video Uploads by Day” or “Comments Added to Videos per User,” giving teams detailed information about user behavior at a granular level.

2. Standardized Dashboard Design and Naming Conventions To maintain clarity and consistency, all dashboards will adhere to a standard design and naming patterns for charts and visual elements. This ensures that users can easily interpret the data without needing assistance from the data team.

Design Standards:

Allowed Chart Types: Only three chart types are permitted for metrics dashboards:
Bar charts: For comparing discrete values, such as the number of users across different segments.
Line charts: For tracking changes over time, such as daily active users over the past month.
Big number tiles: To display current metric values, especially in Overall View dashboards, to highlight critical KPIs (e.g., total users, monthly revenue).
This limited selection of chart types ensures simplicity and uniformity, making it easier for users to understand the data at a glance.

Naming Conventions for Charts:
The naming of charts will follow a consistent pattern to provide users with clear information about what is being measured. The format for chart names will be:

[Entities], [Metric], [Timeframe], [by Segment or Event] (if applicable)
Entity: Refers to the subject of the metric (e.g., "Signups," "New Videos").
Metric: Describes the key performance indicator (e.g., "Weekly Active," "Monthly").
Timeframe: Specifies the time period for the metric (e.g., "Current," "Last 90 Days").
by Segment or Event (optional): Indicates that the data is segmented or related to specific events (e.g., "by Country," "by Account Age").
Example:

"New Videos, Weekly Active, Last 90 Days by Country" (Segment View)
"New Videos, Weekly Active, Last 90 Days by Status" (Activity View)
"New Videos, Weekly Active, Last 90 Days" (Overall View)
3. Recording Metrics in the Data Catalog All metrics included in the dashboards will be documented in a data catalog. This catalog serves as a central resource where users can look up detailed information on how each metric is calculated, what the naming conventions mean, and how the charts are organized. This transparency helps users understand the data at a deeper level and ensures that everyone is working with the same definitions, reducing confusion or misinterpretation.

The data catalog will also provide links to the relevant dashboards, making it easy for users to discover and navigate between them. It is crucial that every metric in the system has a corresponding entry in the catalog, including details on its data sources, calculation methods, and how it ties into the overall metric framework.

4. Linking Dashboards for Seamless Discovery To make it easier for users to explore data across different levels of detail, all child dashboards will include links back to their parent dashboards. This ensures seamless movement between different layers of analysis—users can start with high-level metrics and drill down into segment or activity-specific views with a single click, and vice versa. This interconnected structure promotes intuitive data exploration and reduces the need for manual searches.

Additionally, all dashboard names will follow a consistent format to provide immediate clarity about what users are viewing. The naming format for dashboards will be:

[Level]: [Metric]
Example:

"Overall: Signups"
"Segment: Signups
"Activity: Signups”
This standard naming system provides a clear understanding of the dashboard's focus and hierarchy, improving navigation and reducing ambiguity.

5. “Land, Learn, and Leave” Design Principle The overall design philosophy behind the dashboards is for users to "land, learn, and leave." The goal is to provide a self-service environment where users can quickly access the data they need, understand it without external assistance, and make informed decisions before moving on to other tasks. This principle is supported by:

Clear naming conventions that allow users to immediately know what they are viewing.
Consistent design across all dashboards, reducing the learning curve.
Self-explanatory metrics and chart types that avoid unnecessary complexity.
By following these principles, users should be able to interpret the results of their data exploration without needing to involve the data team for clarification.

6. Other Dashboards Outside of Metrics While the metrics dashboards are owned and maintained by the data team to ensure consistency and reliability, other dashboards can be created outside of this framework. These dashboards might focus on specific team needs, projects, or ad hoc analyses, and do not have to follow the strict design guidelines laid out for metrics dashboards. However, they will remain separate from the core metrics dashboards and may not be certified by the data team.


<startofcode> 

def is_prime(n: int) -> bool:
    """Check if number is prime."""
    if n < 2: return False
    for i in range(2, int(n**0.5)+1):
        if n % i == 0: return False
    return True

<endofcode>
<startofcode>

def digital_root(n: int) -> int:
    """Calculate digital root (recursive sum of digits)."""
    while n >= 10:
        n = sum(int(d) for d in str(n))
    return n

<endofcode>
<startofcode>

from math import factorial

def factorial_digits(n: int) -> int:
    """Sum of factorials of each digit."""
    return sum(factorial(int(d)) for d in str(n))

<endofcode>
<startofcode>

def is_armstrong(n: int) -> bool:
    """Check if number is Armstrong number."""
    digits = str(n)
    return n == sum(int(d)**len(digits) for d in digits)

<endofcode>
<startofcode>

def collatz_sequence(n: int) -> list:
    """Generate Collatz sequence starting with n."""
    sequence = [n]
    while n != 1:
        n = n // 2 if n % 2 == 0 else 3 * n + 1
        sequence.append(n)
    return sequence

<endofcode>
<startofcode>

def alternating_case(s: str) -> str:
    """Convert string to alternating case."""
    return ''.join([c.upper() if i%2==0 else c.lower() for i,c in enumerate(s)])

<endofcode>
<startofcode>

def is_heterogram(s: str) -> bool:
    """Check if all characters in string are unique."""
    return len(set(s.lower())) == len(s)

<endofcode>
<startofcode>

def caesar_cipher(s: str, shift: int) -> str:
    """Implement Caesar cipher with given shift."""
    result = []
    for c in s:
        if c.isalpha():
            base = ord('A') if c.isupper() else ord('a')
            result.append(chr((ord(c) - base + shift) % 26 + base))
        else:
            result.append(c)
    return ''.join(result)

<endofcode>
<startofcode>

def count_consonants(s: str) -> int:
    """Count number of consonants in string."""
    vowels = 'aeiouAEIOU'
    return sum(1 for c in s if c.isalpha() and c not in vowels)

<endofcode>
<startofcode>

def is_pangram(s: str) -> bool:
    """Check if string contains all English alphabet letters."""
    return len(set(c.lower() for c in s if c.isalpha())) == 26

<endofcode>
<startofcode>

def rotate_matrix(matrix: list) -> list:
    """Rotate 2D matrix 90 degrees clockwise."""
    return [list(row) for row in zip(*matrix[::-1])]

<endofcode>
<startofcode>

def chunk_list(lst: list, size: int) -> list:
    """Split list into chunks of given size."""
    return [lst[i:i+size] for i in range(0, len(lst), size)]

<endofcode>
<startofcode>

def list_xor(n: int, lst1: list, lst2: list) -> list:
    """Elements present in either list but not both."""
    return [x for x in lst1 + lst2 if (x in lst1) ^ (x in lst2)]

<endofcode>
<startofcode>

def diagonal_difference(matrix: list) -> int:
    """Calculate absolute difference of matrix diagonals."""
    n = len(matrix)
    return abs(sum(matrix[i][i] - matrix[i][n-1-i] for i in range(n)))

<endofcode>
<startofcode>

def bubble_sort(lst: list) -> list:
    """Implement bubble sort algorithm."""
    arr = lst.copy()
    for i in range(len(arr)-1):
        for j in range(len(arr)-1-i):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr

<endofcode>
<startofcode>

def invert_dictionary(d: dict) -> dict:
    """Swap dictionary keys and values."""
    return {v: k for k, v in d.items()}

<endofcode>
<startofcode>

def deep_flatten(nested_iterable) -> list:
    """Flatten deeply nested iterables."""
    result = []
    for item in nested_iterable:
        if isinstance(item, (list, tuple)):
            result.extend(deep_flatten(item))
        else:
            result.append(item)
    return result

<endofcode>
<startofcode>

def set_operations(a: set, b: set) -> dict:
    """Return union, intersection, and difference of sets."""
    return {
        'union': a | b,
        'intersection': a & b,
        'difference': a - b
    }

<endofcode>
<startofcode>

def word_frequency(text: str) -> dict:
    """Count frequency of words in text."""
    words = text.lower().split()
    return {word: words.count(word) for word in set(words)}

<endofcode>
<startofcode>

import heapq

def priority_queue(operations: list) -> list:
    """Simulate priority queue (max-heap behavior)."""
    heap = []
    result = []
    for op in operations:
        if op == 'pop':
            result.append(-heapq.heappop(heap) if heap else None)
        else:
            heapq.heappush(heap, -op)
    return result

<endofcode>
<startofcode>

from datetime import date

def age_in_days(birthdate: str) -> int:
    """Calculate age in days from YYYY-MM-DD date."""
    today = date.today()
    born = date.fromisoformat(birthdate)
    return (today - born).days

<endofcode>
<startofcode>

from datetime import datetime, timedelta

def time_until_new_year() -> str:
    """Calculate time remaining until next New Year."""
    now = datetime.now()
    next_year = datetime(now.year + 1, 1, 1)
    delta = next_year - now
    return str(delta).split('.')[0]

<endofcode>
<startofcode>

from datetime import datetime

def is_valid_date(date_str: str) -> bool:
    """Validate date string in YYYY-MM-DD format."""
    try:
        datetime.fromisoformat(date_str)
        return True
    except ValueError:
        return False

<endofcode>
<startofcode>

from datetime import date, timedelta

def business_days(start: str, end: str) -> int:
    """Count weekdays between two dates."""
    start_date = date.fromisoformat(start)
    end_date = date.fromisoformat(end)
    delta = end_date - start_date
    return sum(1 for day in range(delta.days + 1)
               if (start_date + timedelta(day)).weekday() < 5)

<endofcode>
<startofcode> 

def binary_search(arr: list, target) -> int:
    """Implement binary search, return index or -1."""
    low, high = 0, len(arr)-1
    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1
    return -1

<endofcode>
<startofcode>

def tower_of_hanoi(n: int, source: str, auxiliary: str, target: str) -> list:
    """Generate solution steps for Tower of Hanoi problem."""
    moves = []
    def _hanoi(n, src, aux, tgt):
        if n > 0:
            _hanoi(n-1, src, tgt, aux)
            moves.append(f"Move disk {n} from {src} to {tgt}")
            _hanoi(n-1, aux, src, tgt)
    _hanoi(n, source, auxiliary, target)
    return moves

<endofcode>
<startofcode>

from math import gcd

def lcm(a: int, b: int) -> int:
    """Calculate Least Common Multiple."""
    return abs(a * b) // gcd(a, b) if a and b else 0

<endofcode>
<startofcode>

def is_harshad_number(n: int) -> bool:
    """Check if number is a Harshad number."""
    if n == 0: return False
    return n % sum(int(d) for d in str(n)) == 0

<endofcode>
<startofcode>

def sieve_of_eratosthenes(n: int) -> list:
    """Generate primes up to n using Sieve of Eratosthenes."""
    sieve = [True] * (n+1)
    sieve[:2] = [False, False]
    for num in range(2, int(n**0.5)+1):
        if sieve[num]:
            sieve[num*num : n+1 : num] = [False]*len(sieve[num*num : n+1 : num])
    return [i for i, prime in enumerate(sieve) if prime]

<endofcode>
<startofcode>

def roman_to_int(s: str) -> int:
    """Convert Roman numeral to integer."""
    roman = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}
    total = 0
    prev_value = 0
    for char in reversed(s):
        value = roman[char]
        total += value if value >= prev_value else -value
        prev_value = value
    return total

<endofcode>
<startofcode>

def int_to_binary(n: int) -> str:
    """Convert integer to binary string without 0b prefix."""
    return bin(n)[2:]

<endofcode>
<startofcode>

def hex_to_rgb(hex_color: str) -> tuple:
    """Convert hex color code to RGB tuple."""
    hex_color = hex_color.lstrip('#')
    return tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))

<endofcode>
<startofcode>

import re

def is_valid_email(email: str) -> bool:
    """Basic email format validation."""
    pattern = r"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$"
    return re.match(pattern, email) is not None

<endofcode>
<startofcode>

def password_strength(password: str) -> str:
    """Evaluate password strength."""
    length = len(password)
    has_upper = any(c.isupper() for c in password)
    has_lower = any(c.islower() for c in password)
    has_digit = any(c.isdigit() for c in password)
    has_special = any(not c.isalnum() for c in password)
    
    score = sum([length >= 8, has_upper, has_lower, has_digit, has_special])
    return ["Weak", "Fair", "Good", "Strong", "Very Strong"][min(score, 4)]

<endofcode>
<startofcode>

def quadratic_roots(a: float, b: float, c: float) -> tuple:
    """Find roots of quadratic equation."""
    discriminant = b**2 - 4*a*c
    if discriminant < 0:
        return (None, None)
    sqrt_discriminant = discriminant**0.5
    return (
        (-b + sqrt_discriminant)/(2*a),
        (-b - sqrt_discriminant)/(2*a)
    )

<endofcode>
<startofcode>

def matrix_multiply(a: list, b: list) -> list:
    """Multiply two matrices."""
    return [[sum(x*y for x,y in zip(row, col)) for col in zip(*b)] for row in a]

<endofcode>
<startofcode>

from math import prod

def geometric_mean(numbers: list) -> float:
    """Calculate geometric mean."""
    return prod(numbers) ** (1/len(numbers)) if numbers else None

<endofcode>
<startofcode>

def is_abundant_number(n: int) -> bool:
    """Check if number is abundant (sum of proper divisors > number)."""
    if n < 1: return False
    return sum(i for i in range(1, n//2+1) if n % i == 0) > n

<endofcode>
<startofcode>

def vector_dot_product(v1: list, v2: list) -> float:
    """Calculate dot product of two vectors."""
    return sum(x*y for x,y in zip(v1, v2))

<endofcode>
<startofcode>

def calculate_bmi(weight: float, height: float) -> float:
    """Calculate Body Mass Index."""
    return weight / (height ** 2)

<endofcode>
<startofcode>

def days_in_month(month: int, year: int) -> int:
    """Return number of days in month."""
    import calendar
    return calendar.monthrange(year, month)[1]

<endofcode>
<startofcode>

def count_words(s: str) -> int:
    """Count number of words in string."""
    return len(s.split())

<endofcode>
<startofcode>

def remove_duplicates(lst: list) -> list:
    """Remove duplicates from list while preserving order."""
    seen = set()
    return [x for x in lst if not (x in seen or seen.add(x))]

<endofcode>
<startofcode>

def list_of_squares(n: int) -> list:
    """Return list of squares up to n."""
    return [i**2 for i in range(1, n+1)]

<endofcode>
<startofcode>

def hypotenuse(a: float, b: float) -> float:
    """Calculate hypotenuse of right triangle."""
    import math
    return math.sqrt(a**2 + b**2)

<endofcode>
<startofcode>

def time_greeting() -> str:
    """Return greeting based on current time."""
    from datetime import datetime
    hour = datetime.now().hour
    if 5 <= hour < 12: return "Good morning!"
    elif 12 <= hour < 18: return "Good afternoon!"
    else: return "Good evening!"

<endofcode>
<startofcode>

def multiply_list(numbers: list) -> float:
    """Multiply all numbers in list."""
    result = 1
    for num in numbers:
        result *= num
    return result

<endofcode>
<startofcode>

def count_occurrences(lst: list, target) -> int:
    """Count occurrences of target in list."""
    return lst.count(target)

<endofcode>
<startofcode>

def is_anagram(s1: str, s2: str) -> bool:
    """Check if two strings are anagrams."""
    return sorted(s1.lower()) == sorted(s2.lower())

<endofcode>
<startofcode>

def linear_search(lst: list, target) -> int:
    """Perform linear search, return index or -1."""
    for i, item in enumerate(lst):
        if item == target:
            return i
    return -1

<endofcode>
<startofcode>

def string_to_list(s: str) -> list:
    """Convert string to list of characters."""
    return list(s)

<endofcode>
<startofcode>

def list_to_string(lst: list) -> str:
    """Convert list of characters to string."""
    return ''.join(lst)

<endofcode>
<startofcode>

def read_file(filename: str) -> str:
    """Read and return file contents."""
    with open(filename, 'r') as f:
        return f.read()

<endofcode>
<startofcode>

def write_file(filename: str, content: str) -> None:
    """Write content to file."""
    with open(filename, 'w') as f:
        f.write(content)

<endofcode>
<startofcode>

def is_integer(n) -> bool:
    """Check if input is integer."""
    return isinstance(n, int)

<endofcode>
<startofcode>

def is_string(n) -> bool:
    """Check if input is string."""
    return isinstance(n, str)

<endofcode>
<startofcode>

def is_list(n) -> bool:
    """Check if input is list."""
    return isinstance(n, list)

<endofcode>
<startofcode>

def celsius_to_fahrenheit(c: float) -> float:
    """Convert Celsius to Fahrenheit."""
    return (c * 9/5) + 32

<endofcode>
<startofcode>

def fahrenheit_to_celsius(f: float) -> float:
    """Convert Fahrenheit to Celsius."""
    return (f - 32) * 5/9

<endofcode>
<startofcode>

def average(numbers: list) -> float:
    """Calculate average of numbers."""
    return sum(numbers)/len(numbers) if numbers else None

<endofcode>
<startofcode>

def factorial_recursive(n: int) -> int:
    """Calculate factorial using recursion."""
    return 1 if n <= 1 else n * factorial_recursive(n-1)

<endofcode>
<startofcode>

def fibonacci_recursive(n: int) -> int:
    """Return nth Fibonacci number using recursion."""
    return n if n <= 1 else fibonacci_recursive(n-1) + fibonacci_recursive(n-2)

<endofcode>
<startofcode>

def gcd_recursive(a: int, b: int) -> int:
    """Calculate GCD using Euclidean algorithm."""
    return a if b == 0 else gcd_recursive(b, a % b)

<endofcode>
<startofcode>

def sum_even_numbers(numbers: list) -> float:
    """Sum all even numbers in list."""
    return sum(num for num in numbers if num % 2 == 0)

<endofcode>
<startofcode>

def factorial_loop(n: int) -> int:
    """Calculate factorial using loop."""
    result = 1
    for i in range(1, n+1):
        result *= i
    return result

<endofcode>
<startofcode>

def fibonacci_sequence(n: int) -> list:
    """Generate Fibonacci sequence up to n terms."""
    sequence = [0, 1]
    while len(sequence) < n:
        sequence.append(sequence[-1] + sequence[-2])
    return sequence[:n]

<endofcode>
<startofcode>

def is_leap_year(year: int) -> bool:
    """Check if year is a leap year."""
    return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)

<endofcode>
<startofcode>

def get_season(month: int) -> str:
    """Return season based on month number."""
    if 3 <= month <= 5:
        return "Spring"
    elif 6 <= month <= 8:
        return "Summer"
    elif 9 <= month <= 11:
        return "Autumn"
    else:
        return "Winter"

<endofcode>
<startofcode>

def get_grade(score: float) -> str:
    """Convert numerical score to letter grade."""
    if score >= 90: return "A"
    elif score >= 80: return "B"
    elif score >= 70: return "C"
    elif score >= 60: return "D"
    else: return "F"

<endofcode>
<startofcode>

def sum_list(numbers: list) -> float:
    """Return sum of list elements."""
    return sum(numbers)

<endofcode>
<startofcode>

def max_in_list(numbers: list) -> float:
    """Find maximum value in list."""
    return max(numbers) if numbers else None

<endofcode>
<startofcode>

def reverse_list(lst: list) -> list:
    """Return reversed list."""
    return lst[::-1]

<endofcode>
<startofcode>

def flatten_list(nested_list: list) -> list:
    """Flatten a nested list."""
    flattened = []
    for item in nested_list:
        if isinstance(item, list):
            flattened.extend(flatten_list(item))
        else:
            flattened.append(item)
    return flattened

<endofcode>
<startofcode>

def are_all_unique(lst: list) -> bool:
    """Check if all elements in list are unique."""
    return len(lst) == len(set(lst))

<endofcode>
<startofcode>

def add(a: float, b: float) -> float:
    """Return the sum of two numbers."""
    return a + b

<endofcode>
<startofcode>

def subtract(a: float, b: float) -> float:
    """Subtract b from a."""
    return a - b

<endofcode>
<startofcode>

def multiply(a: float, b: float) -> float:
    """Multiply two numbers."""
    return a * b

<endofcode>
<startofcode>

def divide(a: float, b: float) -> float:
    """Divide a by b. Returns None if b is 0."""
    return a / b if b != 0 else None

<endofcode>
<startofcode>

def power(base: float, exponent: float) -> float:
    """Calculate base raised to the exponent power."""
    return base ** exponent

<endofcode>

